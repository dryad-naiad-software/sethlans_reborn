--- START OF CHUNK  OF [TOTAL_CHUNKS_PLACEHOLDER] ---

--- FILE_START: sethlans_worker_agent\utils\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_worker_agent
#

--- FILE_END: sethlans_worker_agent\utils\__init__.py ---
--- FILE_START: sethlans_worker_agent\utils\blender_release_parser.py ---
# sethlans_worker_agent/utils/blender_release_parser.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import logging
import re
from urllib.parse import urljoin

import requests
from bs4 import BeautifulSoup

from sethlans_worker_agent import config
from .hash_parser import parse_sha256_content_for_file  # <-- NEW IMPORT

logger = logging.getLogger(__name__)


# --- Blender Release Parsing Functions ---

def fetch_page_soup(url, timeout=10):
    """Helper to fetch a URL and return a BeautifulSoup object."""
    try:
        logger.debug(f"Fetching page: {url}")
        response = requests.get(url, timeout=timeout)
        response.raise_for_status()
        return BeautifulSoup(response.content, 'html.parser')
    except requests.exceptions.RequestException as e:
        logger.error(f"Failed to fetch URL {url}: {e}")
        return None


def parse_major_version_directories(soup):
    """Parses the main releases page soup for Blender major version directory URLs (4.x+ only)."""
    major_version_dir_urls = []
    for link in soup.find_all('a', href=True):
        href = link['href']
        major_minor_dir_match = re.match(r'^/release/Blender(\d+\.\d+(?:\.\d+)?)/$', href)
        logger.debug(f"Checking href: '{href}' with regex. Match: {bool(major_minor_dir_match)}")

        if major_minor_dir_match:
            version_prefix = major_minor_dir_match.group(1)
            major_version_str = version_prefix.split('.')[0]
            try:
                major_version_num = int(major_version_str)
                if major_version_num < 4:
                    logger.debug(f"Skipping Blender major version < 4: {version_prefix}")
                    continue
            except ValueError:
                logger.warning(f"Could not parse major version from directory '{href}'. Skipping.")
                continue
            major_version_dir_urls.append(urljoin(config.BLENDER_RELEASES_URL, href))
        else:
            logger.debug(f"Href '{href}' did not match Blender major version directory pattern.")
    return major_version_dir_urls


def get_sha256_hash_for_zip(sha256_url, expected_zip_filename):
    """Fetches a .sha256 file and extracts the hash for a specific zip filename."""
    file_hash = None
    try:
        hash_response = requests.get(sha256_url, timeout=5)
        hash_response.raise_for_status()

        # --- NEW: Call the new hash_parser utility ---
        file_hash = parse_sha256_content_for_file(hash_response.text, expected_zip_filename)
        # --- END NEW ---

        if not file_hash:
            logger.warning(f"Hash for {expected_zip_filename} not found in {sha256_url}.")
    except requests.exceptions.RequestException as req_e:
        logger.warning(f"Failed to fetch SHA256 for {expected_zip_filename} from {sha256_url} ({req_e})")
    return file_hash


def collect_blender_version_details(major_version_dir_url_blender_org):
    """
    Fetches a major version directory page, parses it for ALL relevant platform/architecture zip details,
    and constructs primary/mirror URLs and fetches hashes.
    Returns a list of dictionaries, one for each platform-specific download found.
    """
    all_platform_versions_found_in_dir = []
    dir_soup = fetch_page_soup(major_version_dir_url_blender_org)
    if not dir_soup:
        return []

    logger.debug(f"  Parsing details from: {major_version_dir_url_blender_org}")
    for file_link in dir_soup.find_all('a', href=True):
        file_href = file_link['href']
        blender_file_match = re.match(r'blender-(\d+\.\d+\.\d+)-(.+)\.(zip|tar\.xz|dmg)$', file_href)
        if blender_file_match:
            full_version = blender_file_match.group(1)
            platform_suffix = blender_file_match.group(2)
            file_extension = blender_file_match.group(3)

            try:
                file_major_version = int(full_version.split('.')[0])
                if file_major_version < 4:
                    continue
            except ValueError:
                continue

            sha256_url = urljoin(major_version_dir_url_blender_org, f"blender-{full_version}.sha256")
            expected_zip_filename_in_hash_file = file_href
            file_hash = get_sha256_hash_for_zip(sha256_url, expected_zip_filename_in_hash_file)

            primary_download_url = urljoin(major_version_dir_url_blender_org, file_href)

            mirrors_for_version = []
            for mirror_base in config.BLENDER_MIRROR_BASE_URLS:
                mirror_url = primary_download_url.replace(config.BLENDER_RELEASES_URL, mirror_base)
                mirrors_for_version.append(mirror_url)

            all_platform_versions_found_in_dir.append({
                "releaseName": f"Blender {full_version}",
                "version": full_version,
                "platform_suffix": platform_suffix,
                "file_extension": file_extension,
                "hash": file_hash,
                "url": primary_download_url,
                "mirrors": mirrors_for_version
            })
    return all_platform_versions_found_in_dir

--- FILE_END: sethlans_worker_agent\utils\blender_release_parser.py ---
--- FILE_START: sethlans_worker_agent\utils\file_hasher.py ---
# sethlans_worker_agent/utils/file_hasher.py

#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#


import hashlib
import datetime
import os

import logging # This should be there
logger = logging.getLogger(__name__) # Get a logger for this module


def calculate_file_sha256(file_path, chunk_size=4096):
    """Calculates the SHA256 hash of a file."""
    sha256_hash = hashlib.sha256()
    try:
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(chunk_size), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except FileNotFoundError:
        logger.error(f"File not found for hash calculation: {file_path}") # <-- Changed print to logger.error
        return None
    except Exception as e:
        logger.error(f"Failed to calculate hash for {file_path}: {e}") # <-- Changed print to logger.error
        return None
--- FILE_END: sethlans_worker_agent\utils\file_hasher.py ---
--- FILE_START: sethlans_worker_agent\utils\file_operations.py ---
# sethlans_worker_agent/utils/file_operations.py

#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import requests
import os
import datetime
import zipfile
import shutil

from .file_hasher import calculate_file_sha256

import logging # This should be there
logger = logging.getLogger(__name__) # Get a logger for this module


def download_file(url, destination_path, expected_hash=None):
    """
    Downloads a file from a given URL to a destination path, and optionally verifies its SHA256 hash.
    """
    logger.info(f"Downloading {url} to {destination_path}...")  # <-- Changed print to logger.info
    try:
        with requests.get(url, stream=True, timeout=300) as r:
            r.raise_for_status()
            with open(destination_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
        logger.info("Download complete.")  # <-- Changed print to logger.info

        if expected_hash:
            logger.info(f"Verifying hash of {destination_path}...")  # <-- Changed print to logger.info
            calculated_hash = calculate_file_sha256(destination_path)
            if calculated_hash and calculated_hash.lower() == expected_hash.lower():
                logger.info("Hash verification SUCCESS!")  # <-- Changed print to logger.info
                return True
            else:
                logger.error(
                    f"Hash verification FAILED! Expected: {expected_hash}, Calculated: {calculated_hash}. Deleting corrupted file.")  # <-- Changed print to logger.error
                os.remove(destination_path)
                return False
        return True

    except requests.exceptions.RequestException as e:
        logger.error(f"Download failed - {e}")  # <-- Changed print to logger.error
        if os.path.exists(destination_path):
            os.remove(destination_path)
        return False
    except Exception as e:
        logger.error(f"An unexpected error occurred during download: {e}")  # <-- Changed print to logger.error
        if os.path.exists(destination_path):
            os.remove(destination_path)
        return False


def extract_zip_file(zip_path, extract_to_path):
    """Extracts a ZIP file to a specified directory."""
    logger.info(f"Extracting {zip_path} to {extract_to_path}...")  # <-- Changed print to logger.info
    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            root_folder_name = ""
            for name in zip_ref.namelist():
                if '/' in name:
                    root_folder_name = name.split('/')[0]
                    break

            actual_extract_path = os.path.join(extract_to_path, root_folder_name)

            os.makedirs(actual_extract_path, exist_ok=True)
            zip_ref.extractall(extract_to_path)

        logger.info(f"Extraction complete to {actual_extract_path}.")  # <-- Changed print to logger.info
        return True, actual_extract_path
    except zipfile.BadZipFile:
        logger.error(f"Invalid ZIP file: {zip_path}")  # <-- Changed print to logger.error
        return False, None
    except Exception as e:
        logger.error(
            f"An unexpected error occurred during extraction of {zip_path}: {e}")  # <-- Changed print to logger.error
        return False, None
--- FILE_END: sethlans_worker_agent\utils\file_operations.py ---
--- FILE_START: sethlans_worker_agent\utils\hash_parser.py ---
# sethlans_worker_agent/utils/hash_parser.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import re
import logging
import datetime  # For logging timestamps

logger = logging.getLogger(__name__)


def parse_sha256_content_for_file(sha256_content_string, expected_filename):
    """
    Parses a string containing SHA256 hash lines to find the hash for a specific filename.
    Assumes format: HASH_VALUE  FILENAME (two or more spaces between hash and filename).
    Args:
        sha256_content_string (str): The entire content of the .sha256 file as a string.
        expected_filename (str): The specific filename (e.g., "blender-4.2.12-windows-x64.zip")
                                 whose hash is to be extracted.
    Returns:
        str: The extracted SHA256 hash (lowercase), or None if not found.
    """
    if not sha256_content_string:
        logger.debug(f"SHA256 content string is empty for filename '{expected_filename}'.")
        return None

    for line in sha256_content_string.splitlines():
        # Look for 64 hex chars, followed by two or more whitespace chars, then the escaped filename
        # Using re.match ensures it's at the beginning of the line
        hash_line_match = re.match(rf'([a-f0-9]{{64}})\s{{2,}}{re.escape(expected_filename)}', line)
        if hash_line_match:
            file_hash = hash_line_match.group(1).lower()
            logger.debug(f"Found hash '{file_hash}' for '{expected_filename}' in line: '{line}'.")
            return file_hash

    logger.debug(f"Hash for '{expected_filename}' not found in provided SHA256 content.")
    return None
--- FILE_END: sethlans_worker_agent\utils\hash_parser.py ---
--- FILE_START: tests\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

--- FILE_END: tests\__init__.py ---
--- FILE_START: tests\e2e\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

--- FILE_END: tests\e2e\__init__.py ---
--- FILE_START: tests\unit\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

--- FILE_END: tests\unit\__init__.py ---
--- FILE_START: tests\unit\worker_agent\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

--- FILE_END: tests\unit\worker_agent\__init__.py ---
--- FILE_START: tests\unit\worker_agent\test_blender_release_parser.py ---
# tests/unit/worker_agent/test_blender_release_parser.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import pytest
import requests  # Still needed for mock_requests_get_for_parser if used
from unittest.mock import MagicMock
from bs4 import BeautifulSoup
from urllib.parse import urljoin

# Import the functions to be tested
from sethlans_worker_agent.utils.blender_release_parser import \
    parse_major_version_directories  # get_sha256_hash_for_zip removed from imports
from sethlans_worker_agent import config

import logging

logging.basicConfig(level=logging.DEBUG, format='[TEST_LOG] %(asctime)s - %(levelname)s - %(name)s - %(message)s')

# --- Dummy Data for Mocking ---
DUMMY_MAIN_RELEASES_HTML = """
<html>
<body>
<a href="/release/Blender1.0/">Blender1.0/</a>
<a href="/release/Blender2.93/">Blender2.93/</a>
<a href="/release/Blender3.6/">Blender3.6/</a>
<a href="/release/Blender4.0/">Blender4.0/</a>
<a href="/release/Blender4.1/">Blender4.1/</a>
</body>
</html>
"""


# REMOVED: DUMMY_SHA256_CONTENT_4_2_12 (no longer needed in this test file)


# --- Fixtures ---
# Simplified mock_requests_get_for_parser as it only needs to provide main HTML now
@pytest.fixture
def mock_requests_get_for_parser(mocker):
    """
    Mocks requests.get for parser tests.
    It returns DUMMY_MAIN_RELEASES_HTML.
    """

    def _mock_get(url, *args, **kwargs):
        mock_response = mocker.Mock(spec=requests.Response)
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None

        # Only handle the main releases URL
        if url == config.BLENDER_RELEASES_URL:
            mock_response.text = DUMMY_MAIN_RELEASES_HTML
            mock_response.content = DUMMY_MAIN_RELEASES_HTML.encode('utf-8')
        else:  # For any other unexpected URL during the test
            mock_response.status_code = 404
            mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError("404 Not Found")
            mock_response.text = ""
            mock_response.content = b""

        mock_response.__enter__ = MagicMock(return_value=mock_response)
        mock_response.__exit__ = MagicMock(return_value=None)
        return mock_response

    mocker.patch('requests.get', side_effect=_mock_get)
    return mocker.patch('requests.get')


# --- Test Case 1: parse_major_version_directories_filters_below_4_x ---

def test_parse_major_version_directories_filters_below_4_x():
    """
    Test Case: parse_major_version_directories_filters_below_4_x
    Purpose: Verify that parse_major_version_directories correctly filters out
             Blender major versions below 4.x from the main releases HTML.
    Asserts:
        - Only URLs for Blender 4.x+ directories are returned.
        - The count of returned URLs is correct.
        - Specific old versions are NOT in the results.
    """
    soup = BeautifulSoup(DUMMY_MAIN_RELEASES_HTML, 'html.parser')

    major_version_urls = parse_major_version_directories(soup)

    assert len(major_version_urls) == 2, \
        f"Expected 2 major version URLs (4.x+), but got {len(major_version_urls)}."

    expected_suffixes = [
        "Blender4.0/", "Blender4.1/"
    ]
    for suffix in expected_suffixes:
        assert urljoin(config.BLENDER_RELEASES_URL, suffix) in major_version_urls, \
            f"Expected URL for {suffix} to be in the list."

    assert urljoin(config.BLENDER_RELEASES_URL, "Blender1.0/") not in major_version_urls, \
        "Blender1.0/ should have been filtered out."
    assert urljoin(config.BLENDER_RELEASES_URL, "Blender2.93/") not in major_version_urls, \
        "Blender2.93/ should have been filtered out."
    assert urljoin(config.BLENDER_RELEASES_URL, "Blender3.6/") not in major_version_urls, \
        "Blender3.6/ should have been filtered out."

    print(f"\n[UNIT TEST] parse_major_version_directories_filters_below_4_x passed.")

--- FILE_END: tests\unit\worker_agent\test_blender_release_parser.py ---
--- FILE_START: tests\unit\worker_agent\test_file_hasher.py ---
# sethlans_reborn/tests/unit/worker_agent/test_file_hasher.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import pytest
import os
import tempfile
from sethlans_worker_agent.utils.file_hasher import calculate_file_sha256


def test_calculate_file_sha256_basic():
    """
    Tests SHA256 hash calculation for a basic text file.
    The file is written in binary mode to ensure consistent hashing across OS.
    """
    # Create a temporary file with known content (in bytes)
    with tempfile.NamedTemporaryFile(mode='wb+', delete=False) as tmp_file:  # Changed mode to 'wb+'
        tmp_file.write(b"Hello, Sethlans Reborn!")  # Write bytes
        tmp_file_path = tmp_file.name

    try:
        calculated_hash = calculate_file_sha256(tmp_file_path)

        # Corrected expected hash for b"Hello, Sethlans Reborn!"
        expected_hash = "1d68f2316c6a7951f74bd2a3f9c3aab5c2c31b8ab2ba6ac7a2efe08986184e97"

        assert calculated_hash == expected_hash
        print(f"\n[UNIT TEST] SHA256 calculation basic test passed for: {tmp_file_path}")
        print(f"  Calculated: {calculated_hash}")
        print(f"  Expected:   {expected_hash}")
    finally:
        os.remove(tmp_file_path)


def test_calculate_file_sha256_empty_file():
    """
    Tests SHA256 hash calculation for an empty file.
    """
    with tempfile.NamedTemporaryFile(mode='wb+', delete=False) as tmp_file:  # Changed mode to 'wb+'
        tmp_file_path = tmp_file.name

    try:
        calculated_hash = calculate_file_sha256(tmp_file_path)
        # Expected hash for an empty byte string
        expected_hash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
        assert calculated_hash == expected_hash
        print(f"\n[UNIT TEST] SHA256 calculation empty file test passed for: {tmp_file_path}")
    finally:
        os.remove(tmp_file_path)


def test_calculate_file_sha256_non_existent_file():
    """
    Tests SHA256 hash calculation for a non-existent file (should return None).
    """
    non_existent_path = "non_existent_file_12345.txt"
    calculated_hash = calculate_file_sha256(non_existent_path)
    assert calculated_hash is None
    print(f"\n[UNIT TEST] SHA256 calculation non-existent file test passed.")

--- FILE_END: tests\unit\worker_agent\test_file_hasher.py ---
--- FILE_START: tests\unit\worker_agent\test_file_operations.py ---
# sethlans_reborn/tests/unit/worker_agent/test_file_operations.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import pytest
import os
import tempfile
import shutil
import zipfile
import hashlib

import requests

# Import the functions to be tested
from sethlans_worker_agent.utils.file_operations import download_file, extract_zip_file
from sethlans_worker_agent.utils.file_hasher import calculate_file_sha256


# --- Fixtures for common test setup/teardown ---

@pytest.fixture
def temp_dir(tmp_path):
    """Provides a temporary directory for test files."""
    return tmp_path


@pytest.fixture
def mock_requests_get(mocker):
    """
    Mocks requests.get to return a mock response that supports the context manager protocol.
    """
    # This is the mock object that will be returned *by* requests.get
    # and then used as 'r' in 'with ... as r:'
    mock_response_object = mocker.Mock()
    mock_response_object.status_code = 200
    mock_response_object.raise_for_status.return_value = None
    mock_response_object.iter_content.return_value = [b"dummy file content"]  # Default content

    # This mocks requests.get itself.
    # When requests.get() is called, it returns mock_response_object,
    # but that object *also* needs to be a context manager.
    mock_get = mocker.patch('requests.get')

    # Configure mock_get's return_value to be a context manager itself.
    # When mock_get() is called, it returns another mock.
    # When *that* mock's __enter__ is called, it returns mock_response_object.
    mock_get.return_value.__enter__.return_value = mock_response_object
    mock_get.return_value.__exit__.return_value = None

    return mock_get  # Return the patched requests.get mock


# --- Tests for download_file ---

def test_download_file_success(tmp_path, mock_requests_get):
    """Tests successful file download without hash verification."""
    test_url = "http://example.com/test.zip"
    dest_path = tmp_path / "downloaded_file.zip"

    success = download_file(test_url, dest_path)

    assert success is True
    assert os.path.exists(dest_path)
    with open(dest_path, 'rb') as f:
        assert f.read() == b"dummy file content"
    mock_requests_get.assert_called_once_with(test_url, stream=True, timeout=300)  # Now asserts on requests.get
    print(f"\n[UNIT TEST] download_file success test passed. File: {dest_path}")


def test_download_file_http_error(tmp_path, mock_requests_get):
    """Tests download failure due to HTTP error."""
    # Configure the mock response object (which is mock_requests_get.return_value.__enter__.return_value)
    mock_requests_get.return_value.__enter__.return_value.raise_for_status.side_effect = requests.exceptions.HTTPError(
        "404 Not Found")

    test_url = "http://example.com/notfound.zip"
    dest_path = tmp_path / "failed_download.zip"

    success = download_file(test_url, dest_path)

    assert success is False
    assert not os.path.exists(dest_path)
    mock_requests_get.assert_called_once_with(test_url, stream=True, timeout=300)  # Assert requests.get was called
    print(f"\n[UNIT TEST] download_file HTTP error test passed. File: {dest_path}")


def test_download_file_hash_success(tmp_path, mock_requests_get):
    """Tests successful file download with correct hash verification."""
    known_content = b"Content for hash test!"
    known_hash = hashlib.sha256(known_content).hexdigest()

    # Configure the mock response object
    mock_requests_get.return_value.__enter__.return_value.iter_content.return_value = [known_content]
    mock_requests_get.return_value.__enter__.return_value.status_code = 200

    test_url = "http://example.com/hashed.zip"
    dest_path = tmp_path / "hashed_file.zip"

    success = download_file(test_url, dest_path, expected_hash=known_hash)

    assert success is True
    assert os.path.exists(dest_path)
    mock_requests_get.assert_called_once_with(test_url, stream=True, timeout=300)  # Assert requests.get was called
    print(f"\n[UNIT TEST] download_file hash success test passed. File: {dest_path}")


def test_download_file_hash_failure(tmp_path, mock_requests_get):
    """Tests download failure due to incorrect hash verification."""
    known_content = b"Content for hash test!"
    wrong_hash = "a" * 64

    # Configure the mock response object
    mock_requests_get.return_value.__enter__.return_value.iter_content.return_value = [known_content]
    mock_requests_get.return_value.__enter__.return_value.status_code = 200

    test_url = "http://example.com/wrong_hash.zip"
    dest_path = tmp_path / "wrong_hashed_file.zip"

    success = download_file(test_url, dest_path, expected_hash=wrong_hash)

    assert success is False
    assert not os.path.exists(dest_path)
    mock_requests_get.assert_called_once_with(test_url, stream=True, timeout=300)  # Assert requests.get was called
    print(f"\n[UNIT TEST] download_file hash failure test passed. File: {dest_path}")


# --- Tests for extract_zip_file ---

@pytest.fixture
def create_dummy_zip(tmp_path):
    """Creates a dummy zip file for extraction tests."""
    zip_path = tmp_path / "dummy.zip"
    extracted_folder_name = "dummy_extracted_folder"
    content_file = "content.txt"

    with zipfile.ZipFile(zip_path, 'w') as zf:
        zf.writestr(f"{extracted_folder_name}/{content_file}", b"This is dummy content.")

    yield zip_path, extracted_folder_name, content_file


def test_extract_zip_file_success(tmp_path, create_dummy_zip):
    """Tests successful ZIP file extraction."""
    zip_path, extracted_folder_name, content_file = create_dummy_zip
    extract_to_path = tmp_path / "extracted_target"

    success, actual_extract_path = extract_zip_file(zip_path, extract_to_path)

    assert success is True
    assert os.path.exists(actual_extract_path)
    assert os.path.isdir(actual_extract_path)
    assert os.path.exists(os.path.join(actual_extract_path, content_file))
    with open(os.path.join(actual_extract_path, content_file), 'rb') as f:
        assert f.read() == b"This is dummy content."
    print(f"\n[UNIT TEST] extract_zip_file success test passed. Extracted to: {actual_extract_path}")


def test_extract_zip_file_invalid_zip(tmp_path):
    """Tests extraction failure for an invalid ZIP file."""
    invalid_zip_path = tmp_path / "invalid.zip"
    with open(invalid_zip_path, 'wb') as f:
        f.write(b"NOT A ZIP FILE")

    success, actual_extract_path = extract_zip_file(invalid_zip_path, tmp_path / "extract_invalid")

    assert success is False
    assert actual_extract_path is None
    assert not os.path.exists(tmp_path / "extract_invalid")
    print(f"\n[UNIT TEST] extract_zip_file invalid zip test passed.")
--- FILE_END: tests\unit\worker_agent\test_file_operations.py ---
--- FILE_START: tests\unit\worker_agent\test_hash_parser.py ---
# sethlans_reborn/tests/unit/worker_agent/test_hash_parser.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import pytest
import logging

# Import the function to be tested
from sethlans_worker_agent.utils.hash_parser import parse_sha256_content_for_file

# --- Dummy Data for Test ---
# This is a snippet of the SHA256 content we expect to parse
DUMMY_SHA256_CONTENT_FOR_TEST = """
a309f559f9d756e333c0eae97254b57cc24df65d3cddd69270044ee8626c216d  blender-4.2.12-linux-x64.tar.xz
277c2618298368d0a80fe4aec89af8e46c441af850a1d34528ad9f7cd6b9b615  blender-4.2.12-macos-arm64.dmg
e7575e7bb12715984f1195fba3537cb890e12355b473e47a8f55e7bab184f509  blender-4.2.12-macos-x64.dmg
4ee5c4da98afb925cf04ae05b53d66c23f2e8db1d805cd747365a8fca00b880a  blender-4.2.12-windows-arm64.zip
d7b77bf3a925722be87e5b5e429b584d7baa3bcc82579afa7952fc1f8c19d2e1  blender-4.2.12-windows-x64.zip
"""


# --- Test Case 1: parse_sha256_content_for_file_success ---

def test_parse_sha256_content_for_file_success():
    """
    Test Case: parse_sha256_content_for_file_success
    Purpose: Verify that parse_sha256_content_for_file successfully extracts the hash
             for a specific filename from a given SHA256 content string.
    Asserts:
        - The correct SHA256 hash is returned.
    """
    content_string = DUMMY_SHA256_CONTENT_FOR_TEST
    expected_filename = "blender-4.2.12-windows-x64.zip"

    file_hash = parse_sha256_content_for_file(content_string, expected_filename)

    # Expected hash for blender-4.2.12-windows-x64.zip from DUMMY_SHA256_CONTENT_FOR_TEST
    expected_hash_value = "d7b77bf3a925722be87e5b5e429b584d7baa3bcc82579afa7952fc1f8c19d2e1"

    assert file_hash == expected_hash_value, \
        f"Expected hash {expected_hash_value}, but got {file_hash}."

    print(f"\n[UNIT TEST] parse_sha256_content_for_file_success passed.")


# --- Test Case 2: parse_sha256_content_for_file_hash_not_found ---

def test_parse_sha256_content_for_file_hash_not_found():
    """
    Test Case: parse_sha256_content_for_file_hash_not_found
    Purpose: Verify that parse_sha256_content_for_file returns None
             if the hash for the expected filename is not present in the content.
    Asserts:
        - The returned hash is None.
    """
    content_string = DUMMY_SHA256_CONTENT_FOR_TEST
    # This filename is NOT in DUMMY_SHA256_CONTENT_FOR_TEST
    expected_filename = "blender-99.99.99-nonexistent-platform.zip"

    file_hash = parse_sha256_content_for_file(content_string, expected_filename)

    assert file_hash is None, "Should return None if hash for filename is not found."

    print(f"\n[UNIT TEST] parse_sha256_content_for_file_hash_not_found passed.")


# --- Test Case 3: parse_sha256_content_for_file_empty_content ---

def test_parse_sha256_content_for_file_empty_content():
    """
    Test Case: parse_sha256_content_for_file_empty_content
    Purpose: Verify that parse_sha256_content_for_file handles empty content string gracefully.
    Asserts:
        - The returned hash is None.
    """
    content_string = ""  # Empty string input
    expected_filename = "any_file.zip"

    file_hash = parse_sha256_content_for_file(content_string, expected_filename)

    assert file_hash is None, "Should return None for empty content string."

    print(f"\n[UNIT TEST] parse_sha256_content_for_file_empty_content passed.")

--- FILE_END: tests\unit\worker_agent\test_hash_parser.py ---
--- FILE_START: tests\unit\worker_agent\test_system_monitor.py ---
# sethlans_reborn/tests/unit/worker_agent/test_system_monitor.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import pytest
import logging
from unittest.mock import patch, MagicMock

# Import the function to be tested
from sethlans_worker_agent.system_monitor import get_system_info, send_heartbeat
from sethlans_worker_agent import tool_manager

import platform
import socket
from sethlans_worker_agent import config

logger = logging.getLogger(__name__)


# --- Test Case 1: get_system_info_success ---

def test_get_system_info_success(mocker):
    """
    Test Case: get_system_info_success
    Purpose: Verify that get_system_info correctly gathers basic system information
             (hostname, IP, OS) and calls the tool_manager's scanner.
    Asserts:
        - The returned dictionary contains expected system info.
        - tool_manager_instance.scan_for_blender_versions is called correctly.
    """
    # Mock external dependencies: socket, platform, tool_manager_instance
    mock_hostname = "test-host"
    mock_ip_address = "192.168.1.100"
    mock_os_system = "Windows"
    mock_os_release = "10"
    mock_scanned_tools = {"blender": ["4.1.1", "4.2.0"]}

    mocker.patch('socket.gethostname', return_value=mock_hostname)
    # Mock gethostbyname and its potential error
    mock_gethostbyname = mocker.patch('socket.gethostbyname')
    mock_gethostbyname.return_value = mock_ip_address

    mocker.patch('platform.system', return_value=mock_os_system)
    mocker.patch('platform.release', return_value=mock_os_release)  # For Windows

    # Mock the tool_manager_instance.scan_for_blender_versions method
    # It's an instance method, so we mock on the instance imported
    mocker.patch.object(tool_manager.tool_manager_instance,
                        'scan_for_blender_versions',
                        return_value=mock_scanned_tools)

    system_info = get_system_info()

    # Assert 1: Correct system info is returned
    assert system_info['hostname'] == mock_hostname
    assert system_info['ip_address'] == mock_ip_address
    assert system_info['os'] == f"{mock_os_system} {mock_os_release}"

    # Assert 2: available_tools is correctly populated by the mock
    assert system_info['available_tools'] == mock_scanned_tools

    # Assert 3: External calls were made correctly
    socket.gethostname.assert_called_once()
    mock_gethostbyname.assert_called_once_with(mock_hostname)
    platform.system.assert_called_once()
    platform.release.assert_called_once()
    tool_manager.tool_manager_instance.scan_for_blender_versions.assert_called_once()

    print(f"\n[UNIT TEST] get_system_info_success passed.")


# --- Fixture for mocking requests.post ---
@pytest.fixture
def mock_requests_post(mocker):
    """
    Mocks requests.post to return a mock response for heartbeat.
    """
    mock_response = mocker.Mock()
    mock_response.status_code = 200
    mock_response.raise_for_status.return_value = None
    mock_response.json.return_value = {"id": 2, "hostname": "TEST-HOST-2", "is_active": True}  # Mimic manager response

    # --- CORRECTED: Return the patched object itself for assertions ---
    patched_post = mocker.patch('requests.post', return_value=mock_response)
    return patched_post
    # --- END CORRECTED ---


# --- Test Case 2: send_heartbeat_success ---

def test_send_heartbeat_success(mocker, mock_requests_post):
    """
    Test Case: send_heartbeat_success
    Purpose: Verify that send_heartbeat correctly sends a POST request
             and updates WORKER_INFO on successful response.
    Asserts:
        - requests.post is called exactly once with the correct URL and payload.
        - system_monitor.WORKER_INFO is updated with data from the mock response.
    """
    # Mock system_info (since send_heartbeat takes it as an argument)
    test_system_info = {
        "hostname": "test-host-abc",
        "ip_address": "192.168.1.5",
        "os": "TestOS 1.0"
    }

    # Mock tool_manager_instance.scan_for_blender_versions as get_system_info calls it internally,
    # but send_heartbeat doesn't directly interact with it for its core logic.
    # We provide an empty list of tools for this test as it's not the focus.
    mocker.patch.object(tool_manager.tool_manager_instance,
                        'scan_for_blender_versions',
                        return_value={})

    # Clear WORKER_INFO before the test to ensure it's updated
    from sethlans_worker_agent import system_monitor  # Re-import to get actual module and modify global
    system_monitor.WORKER_INFO = {}

    send_heartbeat(test_system_info)

    # Assert 1: requests.post was called correctly
    expected_url = f"{config.MANAGER_API_URL}heartbeat/"
    mock_requests_post.assert_called_once_with(expected_url, json=test_system_info, timeout=5)

    # Assert 2: WORKER_INFO is updated
    assert system_monitor.WORKER_INFO.get('id') == 2
    assert system_monitor.WORKER_INFO.get('hostname') == "TEST-HOST-2"

    print(f"\n[UNIT TEST] send_heartbeat_success passed.")
--- FILE_END: tests\unit\worker_agent\test_system_monitor.py ---

--- END OF CHUNK  OF [TOTAL_CHUNKS_PLACEHOLDER] ---
