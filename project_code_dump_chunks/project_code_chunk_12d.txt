--- START OF CHUNK  OF [TOTAL_CHUNKS_PLACEHOLDER] ---

--- FILE_START: config\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#
--- FILE_END: config\__init__.py ---
--- FILE_START: config\asgi.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()

--- FILE_END: config\asgi.py ---
--- FILE_START: config\settings.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from pathlib import Path # <-- ADDED THIS IMPORT!
import os
import logging

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-^&r@p#+r6h*!@!1u=l!0j_z%z!%^n#b=2#h&l16b%c!0609t'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party apps
    'rest_framework',
    'django_filters',
    'pytest_django',
    # Your custom apps here
    'workers',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# --- NEW: Logging Configuration ---
# Get default log level from environment variable, fallback to INFO for production-like verbosity
LOG_LEVEL = os.getenv('DJANGO_LOG_LEVEL', 'INFO').upper()

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False, # Keep Django's default loggers

    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
        'standard': { # Custom format for standard application logs
            'format': '[{asctime}] [{levelname}] [{name}] {message}',
            'style': '{',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'standard', # Use our custom standard formatter
            'level': 'DEBUG', # Always output DEBUG to console handler, filtering happens at logger level
        },
        # You can add a file handler here if you want logs to go to a file
        # 'file': {
        #     'class': 'logging.handlers.RotatingFileHandler',
        #     'filename': BASE_DIR / 'logs' / 'django.log',
        #     'level': 'INFO',
        #     'formatter': 'standard',
        #     'maxBytes': 1024 * 1024 * 5, # 5 MB
        #     'backupCount': 5,
        # },
    },
    'loggers': {
        # Root logger: catches all messages not handled by specific loggers
        '': {
            'handlers': ['console'],
            'level': LOG_LEVEL, # Use the dynamic log level
            'propagate': True, # Pass messages to parent loggers (e.g., root)
        },
        # Your specific application logger
        'workers': { 
            'handlers': ['console'],
            'level': LOG_LEVEL, 
            'propagate': False, # Don't pass to root if handled here to avoid duplication
        },
        # Example for Django's built-in loggers
        'django': {
            'handlers': ['console'],
            'level': 'INFO', # Keep Django's own logs at INFO by default
            'propagate': False,
        },
        'django.request': {
            'handlers': ['console'],
            'level': 'WARNING', # Requests that return 4xx or 5xx will be logged as WARNING or ERROR
            'propagate': False,
        },
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'INFO', # Log SQL queries at DEBUG level, otherwise INFO
            'propagate': False,
        },
    },
}
--- FILE_END: config\settings.py ---
--- FILE_START: config\urls.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

"""
URL configuration for config project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

from django.contrib import admin
from django.urls import path, include # <-- Make sure 'include' is here

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('workers.urls')), # <-- Add this line for your API
]
--- FILE_END: config\urls.py ---
--- FILE_START: config\wsgi.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()

--- FILE_END: config\wsgi.py ---
--- FILE_START: manage.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

--- FILE_END: manage.py ---
--- FILE_START: pytest.ini ---
# sethlans_reborn/pytest.ini
[pytest]
DJANGO_SETTINGS_MODULE = config.settings
python_files = tests.py test_*.py *_test.py
log_cli = true
log_cli_level = DEBUG
log_cli_format = [%(asctime)s] [%(levelname)s] [%(name)s] %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S
--- FILE_END: pytest.ini ---
--- FILE_START: requirements.txt ---
asgiref==3.9.1
beautifulsoup4==4.13.4
certifi==2025.7.14
charset-normalizer==3.4.2
colorama==0.4.6
Django==5.2.4
django-filter==25.1
djangorestframework==3.16.0
git-filter-repo==2.47.0
idna==3.10
iniconfig==2.1.0
packaging==25.0
pluggy==1.6.0
Pygments==2.19.2
pytest==8.4.1
pytest-django==4.11.1
pytest-mock==3.14.1
requests==2.32.4
soupsieve==2.7
sqlparse==0.5.3
typing_extensions==4.14.1
tzdata==2025.2
urllib3==2.5.0

--- FILE_END: requirements.txt ---
--- FILE_START: sethlans_worker_agent\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 7/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_worker_agent
#

--- FILE_END: sethlans_worker_agent\__init__.py ---
--- FILE_START: sethlans_worker_agent\agent.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#
import time
import logging

# Import the new modules
from . import config
from . import system_monitor
from . import job_processor

# Ensure logging is configured (calls the function in config.py)
# config.configure_worker_logging(logging.DEBUG) # You can override level here for debug runs

# Get a logger for this module
logger = logging.getLogger(__name__)

# Global variable to store worker's own info once registered
WORKER_INFO = {}

if __name__ == "__main__":
    # This initial print is for immediate visibility before logging takes over fully
    print("Sethlans Reborn Worker Agent Starting...")

    # Ensure the Django Manager (sethlans_reborn project) is running at http://127.0.0.1:8000/!

    # Initial system info for the first heartbeat
    initial_system_info = system_monitor.get_system_info()

    system_monitor.send_heartbeat(initial_system_info)

    logger.info("Worker Agent READY.")

    while True:
        system_monitor.send_heartbeat({'hostname': system_monitor.WORKER_INFO['hostname']})

        job_processor.get_and_claim_job()

        time.sleep(min(config.HEARTBEAT_INTERVAL_SECONDS, config.JOB_POLLING_INTERVAL_SECONDS))

--- FILE_END: sethlans_worker_agent\agent.py ---
--- FILE_START: sethlans_worker_agent\config.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import os
import sys
import platform
import logging # <-- NEW IMPORT

# --- Manager API Configuration ---
MANAGER_API_URL = "http://127.0.0.1:8000/api/"

# --- Worker Operation Intervals ---
HEARTBEAT_INTERVAL_SECONDS = 30
JOB_POLLING_INTERVAL_SECONDS = 5

# --- Worker Agent Paths ---
PROJECT_ROOT_FOR_WORKER = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), '..'))

SYSTEM_BLENDER_EXECUTABLE = None

MANAGED_TOOLS_DIR = os.path.join(PROJECT_ROOT_FOR_WORKER, 'sethlans_worker_agent', 'managed_tools')

TEST_BLEND_FILE_PATH = os.path.join(PROJECT_ROOT_FOR_WORKER, 'test_scene.blend')
TEST_OUTPUT_DIR = os.path.join(PROJECT_ROOT_FOR_WORKER, 'render_test_output')

# --- Tool Discovery & Download Configuration ---
BLENDER_RELEASES_URL = "https://download.blender.org/release/"

BLENDER_MIRROR_BASE_URLS = [
    "https://mirror.clarkson.edu/blender/release/",
    "http://ftp.halifax.rwth-aachen.de/blender/release/",
    "http://ftp.nluug.nl/pub/graphics/blender/release/",
]

BLENDER_VERSIONS_CACHE_FILE = os.path.join(MANAGED_TOOLS_DIR, 'blender_versions_cache.json')

# --- Platform and Architecture-specific Blender Download/Executable Mappings ---
PLATFORM_BLENDER_MAP = {
    ('Windows', 'amd64'): {
        'download_suffix': 'windows-x64',
        'download_ext': '.zip',
        'executable_path_in_folder': 'blender.exe'
    },
    ('Windows', 'arm64'): {
        'download_suffix': 'windows-arm64',
        'download_ext': '.zip',
        'executable_path_in_folder': 'blender.exe'
    },
    ('Linux', 'x86_64'): {
        'download_suffix': 'linux-x64',
        'download_ext': '.tar.xz',
        'executable_path_in_folder': 'blender'
    },
    ('Darwin', 'x86_64'): {
        'download_suffix': 'macos-x64',
        'download_ext': '.dmg',
        'executable_path_in_folder': 'blender.app/Contents/MacOS/blender'
    },
    ('Darwin', 'arm64'): {
        'download_suffix': 'macos-arm64',
        'download_ext': '.dmg',
        'executable_path_in_in_folder': 'blender.app/Contents/MacOS/blender'
    }
}

CURRENT_PLATFORM_BLENDER_DETAILS = PLATFORM_BLENDER_MAP.get((platform.system(), platform.machine().lower()))
if not CURRENT_PLATFORM_BLENDER_DETAILS:
    print(f"[WARNING] Unsupported OS/Architecture for Blender management: ({platform.system()}, {platform.machine().lower()}). Auto-download may not work.")

# --- NEW: Centralized Logging Configuration Function ---
def configure_worker_logging(log_level=logging.INFO):
    """
    Configures the basic logging for the worker agent.
    This should be called once at startup.
    """
    # Ensure handlers are not duplicated if called multiple times (e.g., in tests)
    if not logging.root.handlers:
        logging.basicConfig(
            level=log_level,
            format='[%(asctime)s] [%(levelname)s] [%(name)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        # Set specific loggers to DEBUG if the root level is DEBUG
        if log_level == logging.DEBUG:
            logging.getLogger('sethlans_worker_agent.utils.blender_release_parser').setLevel(logging.DEBUG)
            # Add other specific loggers here if you want them at DEBUG
            logging.getLogger('sethlans_worker_agent.tool_manager').setLevel(logging.DEBUG)
            logging.getLogger('sethlans_worker_agent.job_processor').setLevel(logging.DEBUG)
            logging.getLogger('sethlans_worker_agent.system_monitor').setLevel(logging.DEBUG)
            logging.getLogger('sethlans_worker_agent.utils.file_hasher').setLevel(logging.DEBUG)
            logging.getLogger('sethlans_worker_agent.utils.file_operations').setLevel(logging.DEBUG)

# Call logging configuration when config.py is loaded
configure_worker_logging(log_level=logging.INFO) # Default to INFO for normal operation
--- FILE_END: sethlans_worker_agent\config.py ---
--- FILE_START: sethlans_worker_agent\job_processor.py ---
# sethlans_worker_agent/job_processor.py

#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import requests
import json
import datetime
import time
import subprocess
import os

from . import config
from . import system_monitor
from .tool_manager import tool_manager_instance

import logging # This should be there
logger = logging.getLogger(__name__) # Get a logger for this module



# --- Job Processing Functions ---

def execute_blender_job(job_data):
    """
    Executes a Blender render job using subprocess.
    Returns (success: bool, stdout: str, stderr: str, error_message: str)
    """
    job_name = job_data.get('name', 'Unnamed Job')
    blend_file_path = job_data.get('blend_file_path')
    output_file_pattern = job_data.get('output_file_pattern')
    start_frame = job_data.get('start_frame', 1)
    end_frame = job_data.get('end_frame', 1)
    blender_version_req = job_data.get('blender_version')
    render_engine = job_data.get('render_engine', 'CYCLES')

    logger.info(f"Starting render for job '{job_name}'...")  # <-- Changed print to logger.info
    logger.debug(f"  Blend File: {blend_file_path}")  # <-- Changed print to logger.debug
    logger.debug(f"  Output Pattern: {output_file_pattern}")
    logger.debug(f"  Frames: {start_frame}-{end_frame}")
    logger.debug(f"  Engine: {render_engine}")
    if blender_version_req:
        logger.debug(f"  Requested Blender Version: {blender_version_req}")

    # --- Determine which Blender executable to use ---
    blender_to_use = config.SYSTEM_BLENDER_EXECUTABLE
    if blender_version_req:
        logger.info(
            f"Attempting to ensure Blender version {blender_version_req} is available...")  # <-- Changed print to logger.info
        managed_blender_path = tool_manager_instance.ensure_blender_version_available(blender_version_req)
        if managed_blender_path:
            blender_to_use = managed_blender_path
            logger.info(f"Using managed Blender version from: {blender_to_use}")  # <-- Changed print to logger.info
        else:
            logger.warning(
                f"Requested Blender version {blender_version_req} not available/downloadable via management system.")  # <-- Changed print to logger.warning
            if not config.SYSTEM_BLENDER_EXECUTABLE:
                error_message = f"Requested Blender version {blender_version_req} not available, and no system fallback defined. Aborting render for job '{job_name}'."
                logger.error(error_message)  # <-- Changed print to logger.error
                return False, "", "", error_message
            else:
                blender_to_use = config.SYSTEM_BLENDER_EXECUTABLE
                logger.info(
                    f"Falling back to default system Blender: {blender_to_use}")  # <-- Changed print to logger.info
    elif not config.SYSTEM_BLENDER_EXECUTABLE:
        error_message = f"No Blender version requested and no system fallback defined. Aborting render for job '{job_name}'."
        logger.error(error_message)  # <-- Changed print to logger.error
        return False, "", "", error_message

    if not blender_to_use:
        error_message = f"Failed to determine any Blender executable path. Aborting render for job '{job_name}'."
        logger.error(error_message)  # <-- Changed print to logger.error
        return False, "", "", error_message

    # Ensure output directory exists before rendering
    output_dir = os.path.dirname(output_file_pattern)
    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            logger.info(f"Created output directory: {output_dir}")  # <-- Changed print to logger.info
        except OSError as e:
            err_msg = f"Failed to create output directory {output_dir}: {e}"
            logger.error(f"Failed to create output directory: {err_msg}")  # <-- Changed print to logger.error
            return False, "", "", err_msg

    command = [
        blender_to_use,
        "-b",
        blend_file_path,
        "-o", output_file_pattern.replace('####', '#'),
        "-F", "PNG",
        "-E", render_engine,
    ]

    if start_frame == end_frame:
        command.extend(["-f", str(start_frame)])
    else:
        command.extend(["-s", str(start_frame), "-e", str(end_frame), "-a"])

    logger.info(f"Running Blender command: {' '.join(command)}")  # <-- Changed print to logger.info

    stdout_output = ""
    stderr_output = ""
    error_message = ""
    success = False

    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=False,
            cwd=config.PROJECT_ROOT_FOR_WORKER
        )

        stdout_output = process.stdout
        stderr_output = process.stderr

        if process.returncode == 0:
            logger.info("Blender render command exited successfully.")  # <-- Changed print to logger.info
            success = True
        else:
            error_message = f"Blender exited with code {process.returncode}. STDERR: {stderr_output[:500]}..."
            logger.error(f"Blender command failed: {error_message}")  # <-- Changed print to logger.error
            success = False

        logger.debug("--- Blender STDOUT (last 1000 chars) ---")  # <-- Changed print to logger.debug
        logger.debug(stdout_output[-1000:])
        logger.debug("--- Blender STDERR (last 1000 chars) ---")
        logger.debug(stderr_output[-1000:])

    except FileNotFoundError:
        error_message = f"Blender executable not found at '{blender_to_use}'. Please check the path/download."
        logger.error(error_message)  # <-- Changed print to logger.error
    except Exception as e:
        error_message = f"An unexpected error occurred during Blender execution: {e}"
        logger.error(error_message)  # <-- Changed print to logger.error

    return success, stdout_output, stderr_output, error_message


def get_and_claim_job():
    """Polls the manager for available jobs and attempts to claim one. If claimed, executes the job."""
    if not system_monitor.WORKER_INFO.get('id'):
        logger.info("Worker ID not yet known. Skipping job poll.")  # <-- Changed print to logger.info
        return

    jobs_url = f"{config.MANAGER_API_URL}jobs/"
    try:
        logger.info(f"Polling for jobs from {jobs_url}...")  # <-- Changed print to logger.info
        response = requests.get(jobs_url, params={'status': 'QUEUED', 'assigned_worker__isnull': 'true'}, timeout=10)
        response.raise_for_status()
        available_jobs = response.json()

        if available_jobs:
            logger.info(f"Found {len(available_jobs)} available job(s).")  # <-- Changed print to logger.info
            job_to_claim = available_jobs[0]
            job_id = job_to_claim.get('id')
            job_name = job_to_claim.get('name')

            logger.info(f"Attempting to claim job '{job_name}' (ID: {job_id})...")  # <-- Changed print to logger.info

            claim_url = f"{jobs_url}{job_id}/"
            claim_payload = {
                "status": "RENDERING",
                "assigned_worker": system_monitor.WORKER_INFO['id']
            }
            claim_response = requests.patch(claim_url, json=claim_payload, timeout=5)
            claim_response.raise_for_status()

            claimed_job_data = claim_response.json()
            if claimed_job_data.get('status') == 'RENDERING' and claimed_job_data.get('assigned_worker') == \
                    system_monitor.WORKER_INFO['id']:
                logger.info(
                    f"Successfully claimed job '{job_name}'! Starting render...")  # <-- Changed print to logger.info

                success, stdout, stderr, blender_error_msg = execute_blender_job(job_to_claim)

                job_update_payload = {
                    "completed_at": datetime.datetime.now(datetime.timezone.utc).isoformat().replace('+00:00', 'Z'),
                    "last_output": stdout,
                    "error_message": blender_error_msg if blender_error_msg else stderr,
                }

                if success:
                    job_update_payload["status"] = "DONE"
                else:
                    job_update_payload["status"] = "ERROR"

                try:
                    logger.info(
                        f"Reporting job '{job_name}' status '{job_update_payload['status']}' back to manager...")  # <-- Changed print to logger.info
                    report_response = requests.patch(claim_url, json=job_update_payload, timeout=5)
                    report_response.raise_for_status()
                    logger.info(f"Job '{job_name}' status report successful.")  # <-- Changed print to logger.info
                except requests.exceptions.RequestException as e:
                    logger.error(
                        f"Failed to report job status for '{job_name}' - {e}")  # <-- Changed print to logger.error

                return job_to_claim
            else:
                logger.error(
                    f"Claim failed or manager response was unexpected. Job status: {claimed_job_data.get('status')}. Worker assigned: {claimed_job_data.get('assigned_worker')}")  # <-- Changed print to logger.error
        else:
            logger.info("No QUEUED jobs available.")  # <-- Changed print to logger.info

    except requests.exceptions.Timeout:
        logger.error("Job polling or claiming timed out.")  # <-- Changed print to logger.error
    except requests.exceptions.RequestException as e:
        logger.error(f"Job polling or claiming failed - {e}")  # <-- Changed print to logger.error
    except json.JSONDecodeError:
        logger.error("Failed to decode JSON response from job API.")  # <-- Changed print to logger.error
    except Exception as e:
        logger.error(
            f"An unexpected error occurred during job polling/claiming: {e}")  # <-- Changed print to logger.error
--- FILE_END: sethlans_worker_agent\job_processor.py ---
--- FILE_START: sethlans_worker_agent\requirements_worker.txt ---
certifi==2025.7.14
charset-normalizer==3.4.2
idna==3.10
requests==2.32.4
urllib3==2.5.0

--- FILE_END: sethlans_worker_agent\requirements_worker.txt ---
--- FILE_START: sethlans_worker_agent\system_monitor.py ---
# sethlans_worker_agent/system_monitor.py

#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import platform
import socket
import datetime
import requests
import json

from . import config
from .tool_manager import tool_manager_instance

import logging # This should be there
logger = logging.getLogger(__name__) # Get a logger for this module


# Global variable to store worker's own info once registered
WORKER_INFO = {}


def get_system_info():
    """
    Gathers basic system information and available managed tools for the heartbeat.
    """
    hostname = socket.gethostname()
    ip_address = None
    try:
        ip_address = socket.gethostbyname(hostname)
    except socket.gaierror:
        pass

    os_info = platform.system()
    if os_info == 'Windows':
        os_info += f" {platform.release()}"
    elif os_info == 'Linux':
        os_info += f" {platform.version()}"

    available_tools = tool_manager_instance.scan_for_blender_versions()

    return {
        "hostname": hostname,
        "ip_address": ip_address,
        "os": os_info,
        "available_tools": available_tools
    }


def send_heartbeat(system_info):
    """
    Sends a heartbeat to the Django Manager's heartbeat API endpoint.
    Updates the global WORKER_INFO with the worker's ID received from the manager.
    """
    global WORKER_INFO
    heartbeat_url = f"{config.MANAGER_API_URL}heartbeat/"
    try:
        logger.info(f"Sending heartbeat to {heartbeat_url}...")  # <-- Changed print to logger.info
        logger.debug(f"Heartbeat payload: {json.dumps(system_info, indent=2)}")  # <-- Changed print to logger.debug

        response = requests.post(heartbeat_url, json=system_info, timeout=5)
        response.raise_for_status()

        response_data = response.json()
        logger.info(f"Heartbeat successful: HTTP {response.status_code}")  # <-- Changed print to logger.info
        WORKER_INFO = response_data
        logger.info(
            f"Worker registered as ID: {WORKER_INFO.get('id')}, Hostname: {WORKER_INFO.get('hostname')}")  # <-- Changed print to logger.info

    except requests.exceptions.Timeout:
        logger.error("Heartbeat timed out after 5 seconds.")  # <-- Changed print to logger.error
    except requests.exceptions.RequestException as e:
        logger.error(f"Heartbeat failed - {e}")  # <-- Changed print to logger.error
    except json.JSONDecodeError:
        logger.error("Failed to decode JSON response from heartbeat.")  # <-- Changed print to logger.error
    except Exception as e:
        logger.error(f"An unexpected error occurred during heartbeat: {e}")  # <-- Changed print to logger.error
--- FILE_END: sethlans_worker_agent\system_monitor.py ---
--- FILE_START: sethlans_worker_agent\tool_manager.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import json
import logging
import os
import platform
import re

from . import config
from .utils.blender_release_parser import fetch_page_soup, parse_major_version_directories, \
    collect_blender_version_details
from .utils.file_operations import download_file, extract_zip_file

logger = logging.getLogger(__name__)


# Class to encapsulate tool management logic and its cache
class ToolManager:
    _instance = None  # Singleton instance to ensure only one ToolManager object

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ToolManager, cls).__new__(cls)
            # No initialization here in __new__, only instance creation
        return cls._instance

    def __init__(self):
        # Ensure initialization only happens once for the singleton instance
        if not hasattr(self, '_initialized'):
            self.CACHED_BLENDER_DOWNLOAD_INFO = []
            logger.info("Initializing ToolManager instance.")
            self.is_supported_platform = config.CURRENT_PLATFORM_BLENDER_DETAILS is not None
            if not self.is_supported_platform:
                logger.critical(
                    f"ToolManager initialized on an unsupported platform: {platform.system()} {platform.machine().lower()}. Most functionality will be disabled.")
            self._initialized = True  # Set flag after first initialization

    def scan_for_blender_versions(self):
        """
        Scans the managed_tools directory for installed Blender versions, filtering for 4.x and greater,
        and matching the current OS.
        Returns a dictionary like {'blender': ['4.0.0', '4.1.0']}
        """
        blender_versions_found = []
        blender_path = os.path.join(config.MANAGED_TOOLS_DIR, 'blender')

        current_os_download_suffix = config.CURRENT_PLATFORM_BLENDER_DETAILS.get(
            'download_suffix') if config.CURRENT_PLATFORM_BLENDER_DETAILS else None
        if not current_os_download_suffix:
            logger.warning("Cannot scan for Blender: platform details not configured for this OS.")
            return {}

        if not os.path.isdir(blender_path):
            logger.info(f"Blender tools directory does not exist, nothing to scan: {blender_path}")
            return {'blender': []}

        logger.debug(f"Scanning for local Blender versions in: {blender_path}")
        for item_name in os.listdir(blender_path):
            full_path = os.path.join(blender_path, item_name)

            if not os.path.isdir(full_path):
                logger.debug(f"Skipping item '{item_name}': Not a directory.")
                continue

            version_platform_match = re.search(r'blender-(\d+\.\d+\.\d+)-(.+)', item_name)
            if not version_platform_match:
                logger.warning(f"Could not extract version/platform from folder name '{item_name}'. Skipping.")
                continue

            version_str = version_platform_match.group(1)
            platform_suffix_found = version_platform_match.group(2)

            if platform_suffix_found != current_os_download_suffix:
                logger.debug(
                    f"Skipping folder '{item_name}': Platform '{platform_suffix_found}' doesn't match current OS.")
                continue

            # This call itself contains checks for executable path existence
            if not self._get_managed_blender_executable_full_path(item_name):
                logger.warning(f"Skipping folder '{item_name}': No recognized blender executable found.")
                continue

            try:
                major_version = int(version_str.split('.')[0])
                if major_version < 4:
                    logger.debug(f"Skipping managed Blender version < 4.x: {version_str}")
                    continue
            except (ValueError, IndexError):
                logger.warning(f"Could not parse major version from '{version_str}'. Skipping.")
                continue

            # If we passed all checks, it's a valid version
            logger.info(f"  Found managed Blender version: {version_str} for {platform_suffix_found}")
            blender_versions_found.append(version_str)

        blender_versions_found.sort()

        if not blender_versions_found:
            logger.info(
                f"No Blender versions 4.x+ found for {platform.system()} {platform.machine().lower()} in {blender_path}.")

        return {'blender': blender_versions_found}

    def _load_blender_cache(self):
        """Helper to load Blender download info from the local JSON cache file."""
        if os.path.exists(config.BLENDER_VERSIONS_CACHE_FILE):
            try:
                with open(config.BLENDER_VERSIONS_CACHE_FILE, 'r') as f:
                    loaded_data_list = json.load(f)
                    self.CACHED_BLENDER_DOWNLOAD_INFO = loaded_data_list
                    logger.info(f"Loaded Blender download info from local cache: {config.BLENDER_VERSIONS_CACHE_FILE}.")
                    return True
            except json.JSONDecodeError:
                logger.warning(f"Blender versions cache file corrupted. Will re-generate.")
                self.CACHED_BLENDER_DOWNLOAD_INFO = []
            except Exception as e:
                logger.warning(f"Failed to load Blender versions cache: {e}. Will re-generate.")
        return False

    def _save_blender_cache(self, data_list):
        """Helper to save Blender download info to the local JSON cache file."""
        try:
            os.makedirs(os.path.dirname(config.BLENDER_VERSIONS_CACHE_FILE), exist_ok=True)
            with open(config.BLENDER_VERSIONS_CACHE_FILE, 'w') as f:
                json.dump(data_list, f, indent=4)
            logger.info(f"Saved generated Blender download info to local cache: {config.BLENDER_VERSIONS_CACHE_FILE}.")
            return True
        except Exception as e:
            logger.error(f"Failed to save Blender versions cache: {e}")
            return False

    def _filter_and_process_major_minor_versions(self, versions_by_major_minor_raw):
        """
        Takes raw collected version data (grouped by major.minor) and filters down
        to the latest patch for each (major.minor, platform_suffix) combination.
        Returns a LIST of dictionaries, where each dict represents the latest version
        for a specific major.minor AND platform.
        """
        final_list_of_versions = []

        for major_minor_key, versions_for_major_minor in versions_by_major_minor_raw.items():
            versions_by_platform_suffix = {}
            for version_info in versions_for_major_minor:
                platform_suffix = version_info.get('platform_suffix')
                if platform_suffix not in versions_by_platform_suffix:
                    versions_by_platform_suffix[platform_suffix] = []
                versions_by_platform_suffix[platform_suffix].append(version_info)

            for platform_suffix_key, versions_list_for_platform in versions_by_platform_suffix.items():
                versions_list_for_platform.sort(key=lambda x: [int(v) for v in x['version'].split('.')], reverse=True)

                if versions_list_for_platform:
                    latest_version_for_platform = versions_list_for_platform[0]
                    final_list_of_versions.append(latest_version_for_platform)
                    logger.info(
                        f"  Selected latest for {major_minor_key} series and platform '{platform_suffix_key}': {latest_version_for_platform['version']}")
                else:
                    logger.debug(
                        f"No versions found for {major_minor_key} series and platform '{platform_suffix_key}'.")

        return final_list_of_versions

    def generate_and_cache_blender_download_info(self):
        """
        Orchestrates the generation of comprehensive Blender download info.
        Tries to load from cache, otherwise performs dynamic discovery, filters, and saves.
        Returns a dictionary mapping version string to its download info dictionary.
        This dict will be filtered for the CURRENT OS, for easier lookup by ensure_blender_version_available().
        """
        # Try to load from cache file first
        if self._load_blender_cache():
            logger.info(f"Using in-memory cache for Blender download info (loaded from file).")

            current_platform_suffix = config.CURRENT_PLATFORM_BLENDER_DETAILS.get(
                'download_suffix') if config.CURRENT_PLATFORM_BLENDER_DETAILS else None
            if not current_platform_suffix:
                logger.error(
                    f"Cannot filter cache for unsupported OS: {platform.system()} {platform.machine().lower()}.")
                return {}

            filtered_cache_for_current_os = {}
            for entry in self.CACHED_BLENDER_DOWNLOAD_INFO:
                if entry.get('platform_suffix') == current_platform_suffix:
                    filtered_cache_for_current_os[entry['version']] = entry
            self.CACHED_BLENDER_DOWNLOAD_INFO = filtered_cache_for_current_os
            return self.CACHED_BLENDER_DOWNLOAD_INFO

        logger.info(f"Performing dynamic Blender download info generation (4.x+ only) with mirrors...")

        versions_by_major_minor = {}

        try:
            main_soup = fetch_page_soup(config.BLENDER_RELEASES_URL)
            if not main_soup:
                logger.error(f"Could not fetch main Blender releases page.")
                return {}

            major_version_dir_urls = parse_major_version_directories(main_soup)

            for major_version_dir_url_blender_org in major_version_dir_urls:
                versions_from_dir = collect_blender_version_details(
                    major_version_dir_url_blender_org)

                for version_data in versions_from_dir:
                    major_minor_key = ".".join(version_data['version'].split('.')[:2])
                    if major_minor_key not in versions_by_major_minor:
                        versions_by_major_minor[major_minor_key] = []
                    versions_by_major_minor[major_minor_key].append(version_data)

                if not versions_from_dir:
                    logger.info(
                        f"No 4.x+ zip/tar.xz/dmg files found in {major_version_dir_url_blender_org}")

        except Exception as e:
            logger.error(f"An unexpected error occurred during URL discovery/generation: {e}")
            return {}

        generated_info_list_all_platforms = self._filter_and_process_major_minor_versions(versions_by_major_minor)

        self._save_blender_cache(generated_info_list_all_platforms)

        current_platform_suffix = config.CURRENT_PLATFORM_BLENDER_DETAILS.get(
            'download_suffix') if config.CURRENT_PLATFORM_BLENDER_DETAILS else None

        if not current_platform_suffix:
            logger.error(
                f"Cannot filter generated info for unsupported OS: {platform.system()} {platform.machine().lower()}.")
            return {}

        final_info_for_current_os = {}
        for entry_data in generated_info_list_all_platforms:
            if entry_data.get('platform_suffix') == current_platform_suffix:
                final_info_for_current_os[entry_data['version']] = entry_data

        self.CACHED_BLENDER_DOWNLOAD_INFO = final_info_for_current_os
        return final_info_for_current_os

    def _get_managed_blender_executable_full_path(self, folder_name):
        """
        Determines the full absolute path to the blender executable within an extracted Blender folder.
        'folder_name' is like 'blender-X.Y.Z-platform'.
        Returns the absolute path to the executable (e.g., 'C:/.../blender.exe') or None if not found.
        This function strictly checks only the executable path for the CURRENT_PLATFORM_BLENDER_DETAILS.
        """
        if not config.CURRENT_PLATFORM_BLENDER_DETAILS:
            logger.error(
                f"Cannot determine executable path for unsupported OS: {platform.system()} {platform.machine().lower()}")
            return None

        base_path = os.path.join(config.MANAGED_TOOLS_DIR, 'blender', folder_name)

        expected_exe_subpath = config.CURRENT_PLATFORM_BLENDER_DETAILS['executable_path_in_folder']
        full_exe_path = os.path.join(base_path, expected_exe_subpath)

        if os.path.exists(full_exe_path):
            return full_exe_path
        else:
            logger.error(
                f"Blender executable not found for managed folder '{folder_name}' at expected path: {full_exe_path}. Double check platform mapping or extraction.")
            return None

    def get_blender_executable_path(self, version_string):
        """
        Constructs the absolute path to the blender executable for a managed version based on current OS/Arch.
        This method is called externally (e.g., by job_processor).
        """
        if not config.CURRENT_PLATFORM_BLENDER_DETAILS:
            logger.error(
                f"Cannot get Blender executable path for unsupported OS: {platform.system()} {platform.machine().lower()}")
            return None

        platform_suffix = config.CURRENT_PLATFORM_BLENDER_DETAILS['download_suffix']
        blender_folder_name = f"blender-{version_string}-{platform_suffix}"

        return self._get_managed_blender_executable_full_path(blender_folder_name)

    def ensure_blender_version_available(self, required_version):
        """
        Checks if a Blender version is available locally. If not, downloads and extracts it.
        Uses the generated local JSON info for download URLs, trying mirrors if primary fails.
        Returns the path to the executable if successful, None otherwise.
        """
        logger.info(f"Checking for Blender version {required_version} availability.")

        if not config.CURRENT_PLATFORM_BLENDER_DETAILS:
            logger.error(
                f"Cannot manage Blender versions for unsupported OS: {platform.system()} {platform.machine().lower()}.")
            return None

        # First, check if the required version is already present and correctly identified by scanner
        available_tools = self.scan_for_blender_versions()
        if 'blender' in available_tools and required_version in available_tools['blender']:
            logger.info(
                f"Blender version {required_version} already available locally. Path: {self.get_blender_executable_path(required_version)}")
            return self.get_blender_executable_path(required_version)

        # If not available locally, try to discover and download it using generated info
        # This returns the filtered dict for the CURRENT OS, keyed by version.
        blender_download_info = self.generate_and_cache_blender_download_info()
        version_entry_for_current_os = blender_download_info.get(required_version)

        if version_entry_for_current_os:
            primary_url = version_entry_for_current_os.get('url')
            mirrors = version_entry_for_current_os.get('mirrors', [])
            expected_hash = version_entry_for_current_os.get('hash')
            download_ext = version_entry_for_current_os.get('file_extension')
            platform_suffix_from_entry = version_entry_for_current_os.get('platform_suffix')

            if not download_ext:
                logger.error(f"Missing download extension for {required_version} in cache. Cannot download.")
                return None

            download_urls_to_try = [primary_url] + mirrors

            downloaded_successfully = False
            final_download_url = None
            for url_to_try in download_urls_to_try:
                if not url_to_try:
                    continue

                temp_file_name = f"blender-{required_version}-{platform_suffix_from_entry}{download_ext}"
                temp_file_path = os.path.join(config.MANAGED_TOOLS_DIR, 'blender', temp_file_name)
                extract_to_path = os.path.join(config.MANAGED_TOOLS_DIR, 'blender')

                os.makedirs(extract_to_path, exist_ok=True)

                if download_file(url=url_to_try, destination_path=temp_file_path, expected_hash=expected_hash):
                    downloaded_successfully = True
                    final_download_url = url_to_try
                    break
                else:
                    logger.warning(f"Failed to download from primary/mirror URL: {url_to_try}. Trying next...")

            if downloaded_successfully:
                # This is the standardized folder name we expect for all our logic
                expected_folder_name = f"blender-{required_version}-{platform_suffix_from_entry}"
                expected_final_path = os.path.join(extract_to_path, expected_folder_name)

                success, actual_extract_path = extract_zip_file(zip_path=temp_file_path,
                                                                extract_to_path=extract_to_path)
                if success:
                    # Clean up the downloaded archive first
                    os.remove(temp_file_path)
                    logger.info(f"Cleaned up temporary download file: {temp_file_path}")

                    # --- This is the new robust part ---
                    # If the extracted folder name is not what we expect, rename it.
                    if actual_extract_path and actual_extract_path != expected_final_path:
                        logger.info(
                            f"Standardizing extracted folder name from '{os.path.basename(actual_extract_path)}' to '{expected_folder_name}'.")
                        try:
                            os.rename(actual_extract_path, expected_final_path)
                        except OSError as e:
                            logger.error(f"Failed to rename extracted folder: {e}")
                            return None  # Can't proceed if rename fails

                    # Now we can be certain the executable path will be found
                    executable_path = self.get_blender_executable_path(required_version)
                    if executable_path:
                        logger.info(
                            f"Successfully downloaded and extracted Blender {required_version}. Path: {executable_path}")
                        return executable_path
                    else:
                        # This case would indicate a problem with the config or archive contents
                        logger.error(
                            f"Extraction seemed successful, but could not find the executable for {required_version}.")
                        return None
                else:
                    logger.error(f"FAILED to extract Blender {required_version} from {final_download_url}.")
                    return None
            else:
                logger.error(
                    f"Failed to download Blender {required_version} for {platform.system()} {platform.machine().lower()} from any available URL.")
                return None
        else:
            logger.error(
                f"Requested Blender version {required_version} for {platform.system()} {platform.machine().lower()} not found in generated download info (blender_versions_cache.json) or is not 4.x+.")
            return None


# --- Create a single instance of ToolManager for other modules to import and use ---
tool_manager_instance = ToolManager()

--- FILE_END: sethlans_worker_agent\tool_manager.py ---

--- END OF CHUNK  OF [TOTAL_CHUNKS_PLACEHOLDER] ---
