--- START OF CHUNK 3 OF [TOTAL_CHUNKS_PLACEHOLDER] ---

--- FILE_START: tests\unit\worker_agent\test_tool_manager.py ---
# sethlans_reborn/tests/unit/worker_agent/test_tool_manager.py
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/23/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

import json
import logging
import os

from sethlans_worker_agent import config
# Import the ToolManager instance and config for testing
from sethlans_worker_agent.tool_manager import tool_manager_instance

logger = logging.getLogger(__name__)


# --- Test Case 1: scan_for_blender_versions_success_windows_x64 ---

def test_scan_for_blender_versions_success_windows_x64(mocker):
    """
    Test Case: scan_for_blender_versions_success_windows_x64
    Purpose: Verify that scan_for_blender_versions correctly identifies and filters
             locally installed Blender versions for a Windows x64 system.
    Asserts:
        - The returned dictionary contains the correct Blender versions for Windows x64.
        - Correct os and config calls are made.
    """
    # Mock config.MANAGED_TOOLS_DIR to point to a predictable test path
    mocker.patch.object(config, 'MANAGED_TOOLS_DIR', "/tmp/managed_tools_test")

    # Mock os.path.exists and os.path.isdir to simulate directory structure
    # and os.listdir to simulate folder contents
    mock_os_path_exists = mocker.patch('os.path.exists')
    mock_os_path_isdir = mocker.patch('os.path.isdir')
    mock_os_listdir = mocker.patch('os.listdir')

    # Mock config.CURRENT_PLATFORM_BLENDER_DETAILS for a Windows x64 worker
    mock_config_platform_details = {
        'download_suffix': 'windows-x64',
        'executable_path_in_folder': 'blender.exe'
    }
    mocker.patch.object(config, 'CURRENT_PLATFORM_BLENDER_DETAILS', mock_config_platform_details)

    # Mock _get_managed_blender_executable_full_path as it's an internal helper call
    # It should return a path if the executable is "found" in the simulated folder
    mock_get_executable_path_helper = mocker.patch.object(
        tool_manager_instance, '_get_managed_blender_executable_full_path', return_value="/mock/path/blender.exe"
    )

    # --- Simulate directory and file existence ---
    # managed_tools_test/blender/
    # ├── blender-3.6.0-windows-x64/ (should be skipped due to < 4.x in final output, but helper is called)
    # ├── blender-4.0.0-windows-x64/
    # ├── blender-4.1.0-windows-x64/
    # ├── blender-4.1.1-windows-x64/
    # ├── blender-4.1.1-linux-x64/ (should be skipped due to platform mismatch, helper not called)
    # └── other_folder/ (not blender- prefix, helper not called)

    mock_blender_path = os.path.join(config.MANAGED_TOOLS_DIR, 'blender')
    mock_os_path_exists.side_effect = lambda path: True if path == mock_blender_path else False
    mock_os_path_isdir.side_effect = lambda path: True if path.startswith(mock_blender_path) else False
    mock_os_listdir.return_value = [
        "blender-3.6.0-windows-x64",
        "blender-4.0.0-windows-x64",
        "blender-4.1.0-windows-x64",
        "blender-4.1.1-windows-x64",
        "blender-4.1.1-linux-x64",
        "other_folder"
    ]

    # Run the method under test
    available_tools = tool_manager_instance.scan_for_blender_versions()

    # Assertions
    # Only 4.x+ Windows x64 versions should be returned in final output
    assert available_tools == {'blender': ['4.0.0', '4.1.0', '4.1.1']}
    mock_os_listdir.assert_called_once_with(mock_blender_path)

    # Verify calls to the internal helper _get_managed_blender_executable_full_path
    # It is called for all folders matching 'blender-X.Y.Z-platform' AND the current OS suffix
    # So, 4.0.0, 4.1.0, 4.1.1, 3.6.0 (all windows-x64 matches)
    assert mock_get_executable_path_helper.call_count == 4

    mock_get_executable_path_helper.assert_any_call("blender-3.6.0-windows-x64")
    mock_get_executable_path_helper.assert_any_call("blender-4.0.0-windows-x64")
    mock_get_executable_path_helper.assert_any_call("blender-4.1.0-windows-x64")
    mock_get_executable_path_helper.assert_any_call("blender-4.1.1-windows-x64")

    print(f"\n[UNIT TEST] scan_for_blender_versions_success_windows_x64 passed.")


# --- Test Case 2: get_blender_executable_path_windows_x64_success ---

def test_get_blender_executable_path_windows_x64_success(mocker):
    """
    Test Case: get_blender_executable_path_windows_x64_success
    Purpose: Verify that get_blender_executable_path returns the correct absolute path
             to the Blender executable for a Windows x64 system.
    Asserts:
        - The returned path is correct.
        - os.path.exists is called to check for the executable.
    """
    # Define dummy values
    test_version = "4.2.12"
    mock_managed_tools_dir = "/mock/managed_tools_root"
    mock_expected_exe_subpath = "blender.exe"
    mock_full_exe_path = os.path.join(mock_managed_tools_dir, "blender", f"blender-{test_version}-windows-x64",
                                      mock_expected_exe_subpath)

    # Mock config.MANAGED_TOOLS_DIR
    mocker.patch.object(config, 'MANAGED_TOOLS_DIR', mock_managed_tools_dir)

    # Mock config.CURRENT_PLATFORM_BLENDER_DETAILS for a Windows x64 worker
    mock_config_platform_details = {
        'download_suffix': 'windows-x64',
        'executable_path_in_folder': 'blender.exe'
    }
    mocker.patch.object(config, 'CURRENT_PLATFORM_BLENDER_DETAILS', mock_config_platform_details)

    # Mock os.path.exists to simulate the executable existing
    mock_os_path_exists = mocker.patch('os.path.exists', return_value=True)

    # Run the method under test
    returned_path = tool_manager_instance.get_blender_executable_path(test_version)

    # Assertions
    assert returned_path == mock_full_exe_path, \
        f"Expected path {mock_full_exe_path}, but got {returned_path}."

    # Assert os.path.exists was called once with the correct full path
    mock_os_path_exists.assert_called_once_with(mock_full_exe_path)

    print(f"\n[UNIT TEST] get_blender_executable_path_windows_x64_success passed.")


# --- Test Case 3: test_get_blender_executable_path_not_found ---

def test_get_blender_executable_path_not_found(mocker):
    """
    Test Case: test_get_blender_executable_path_not_found
    Purpose: Verify that get_blender_executable_path returns None
             if the Blender executable file does not exist.
    Asserts:
        - The returned path is None.
        - os.path.exists is called exactly once with the expected path for the current OS.
    """
    # Define dummy values
    test_version = "4.2.12"
    mock_managed_tools_dir = "/mock/managed_tools_root"
    mock_full_exe_path_win = os.path.join(mock_managed_tools_dir, "blender", f"blender-{test_version}-windows-x64",
                                          "blender.exe")

    # Mock config.MANAGED_TOOLS_DIR
    mocker.patch.object(config, 'MANAGED_TOOLS_DIR', mock_managed_tools_dir)

    # Mock config.CURRENT_PLATFORM_BLENDER_DETAILS for a Windows x64 worker
    mock_config_platform_details = {
        'download_suffix': 'windows-x64',
        'executable_path_in_folder': 'blender.exe'
    }
    mocker.patch.object(config, 'CURRENT_PLATFORM_BLENDER_DETAILS', mock_config_platform_details)

    # Mock os.path.exists to simulate the executable NOT existing
    mock_os_path_exists = mocker.patch('os.path.exists', return_value=False)

    # Run the method under test
    returned_path = tool_manager_instance.get_blender_executable_path(test_version)

    # Assertions
    assert returned_path is None, \
        "Expected path to be None when executable does not exist."

    # Assert os.path.exists was called exactly once with the correct expected path for Windows
    assert mock_os_path_exists.call_count == 1, \
        f"Expected os.path.exists to be called 1 time, but got {mock_os_path_exists.call_count}."
    mock_os_path_exists.assert_called_once_with(mock_full_exe_path_win)

    print(f"\n[UNIT TEST] get_blender_executable_path_not_found passed.")


# --- Test Case 4: test_load_blender_cache_success ---

def test_load_blender_cache_success(mocker):
    """
    Test Case: test_load_blender_cache_success
    Purpose: Verify that _load_blender_cache successfully loads valid JSON data
             from a mocked cache file and populates self.CACHED_BLENDER_DOWNLOAD_INFO.
    Asserts:
        - The method returns True on successful load.
        - The cache is correctly populated with the raw loaded data.
        - Correct os.path.exists and open() calls are made.
    """
    # Dummy cache file content that _load_blender_cache expects to read
    dummy_cache_content = [
        {"version": "4.2.12", "platform_suffix": "windows-x64", "url": "http://example.com/win.zip",
         "hash": "winhash_4.2.12"},
        {"version": "4.1.1", "platform_suffix": "linux-x64", "url": "http://example.com/linux.tar.xz",
         "hash": "linuxhash_4.1.1"},
        {"version": "4.0.0", "platform_suffix": "macos-arm64", "url": "http://example.com/mac.dmg",
         "hash": "machash_4.0.0"}
    ]

    # Mock config.BLENDER_VERSIONS_CACHE_FILE
    mocker.patch.object(config, 'BLENDER_VERSIONS_CACHE_FILE', "/mock/cache/blender_versions_cache.json")

    # Mock os.path.exists to simulate cache file existing
    mock_os_path_exists = mocker.patch('os.path.exists', return_value=True)

    # Mock built-in open() to return a mock file object with our dummy content
    mock_file = mocker.mock_open(read_data=json.dumps(dummy_cache_content))
    mocker.patch('builtins.open', mock_file)

    # Reset instance cache before test (Important for singletons in tests)
    # When _load_blender_cache is called by a test, tool_manager_instance is already created.
    # The _initialized flag ensures __init__ logic runs only once.
    # We just need to ensure CACHED_BLENDER_DOWNLOAD_INFO is clean for this specific test.
    tool_manager_instance.CACHED_BLENDER_DOWNLOAD_INFO = []

    # Run the method under test
    success = tool_manager_instance._load_blender_cache()

    # Assertions
    assert success is True, "_load_blender_cache should return True on successful load."

    # Assert open() was called correctly
    mock_file.assert_called_once_with(config.BLENDER_VERSIONS_CACHE_FILE, 'r')
    mock_file.return_value.read.assert_called_once()  # Ensure content was read

    # Assert os.path.exists was called
    mock_os_path_exists.assert_called_once_with(config.BLENDER_VERSIONS_CACHE_FILE)

    # Assert CACHED_BLENDER_DOWNLOAD_INFO is populated with the full raw data list
    assert tool_manager_instance.CACHED_BLENDER_DOWNLOAD_INFO == dummy_cache_content, \
        "CACHED_BLENDER_DOWNLOAD_INFO should be populated with the full raw data list."

    print(f"\n[UNIT TEST] _load_blender_cache_success passed.")


# --- Test Case 5: test_save_blender_cache_success ---

def test_save_blender_cache_success(mocker):
    """
    Test Case: test_save_blender_cache_success
    Purpose: Verify that _save_blender_cache successfully saves a list of dictionaries
             to a mocked cache file.
    Asserts:
        - The method returns True on successful save.
        - os.makedirs is called correctly.
        - The content written to the mock file matches the expected JSON string.
    """
    # Dummy data to be saved to the cache file
    dummy_data_to_save = [
        {"version": "4.2.12", "platform_suffix": "windows-x64", "url": "http://example.com/win.zip"},
        {"version": "4.1.1", "platform_suffix": "linux-x64", "url": "http://example.com/linux.tar.xz"}
    ]

    # Expected JSON string that would be written by json.dump
    expected_json_output = json.dumps(dummy_data_to_save, indent=4)  # REMOVED + "\n"

    # Mock config.BLENDER_VERSIONS_CACHE_FILE
    mock_cache_file_path = "/mock/cache/blender_versions_cache.json"
    mocker.patch.object(config, 'BLENDER_VERSIONS_CACHE_FILE', mock_cache_file_path)

    # Mock os.makedirs (ensure it's called, but doesn't do anything real)
    mock_os_makedirs = mocker.patch('os.makedirs')

    # Mock built-in open() for writing
    mock_file = mocker.mock_open()  # Creates a mock file object
    mocker.patch('builtins.open', mock_file)

    # Run the method under test
    success = tool_manager_instance._save_blender_cache(dummy_data_to_save)

    # Assertions
    assert success is True, "_save_blender_cache should return True on successful save."

    # Assert os.makedirs was called correctly
    mock_os_makedirs.assert_called_once_with(os.path.dirname(mock_cache_file_path), exist_ok=True)

    # Assert open() was called with correct path and mode
    mock_file.assert_called_once_with(mock_cache_file_path, 'w')

    # Assert the content written to the mock file handle's 'write' method
    # json.dump writes in chunks, so we collect all the write calls and join them
    written_content = "".join(call_arg.args[0] for call_arg in mock_file().write.call_args_list)
    assert written_content == expected_json_output, \
        "The content written to the cache file should match the expected JSON output."

    print(f"\n[UNIT TEST] _save_blender_cache_success passed.")


# --- Test Case 6: test_filter_and_process_major_minor_versions_success ---

def test_filter_and_process_major_minor_versions_success(mocker):
    """
    Test Case: test_filter_and_process_major_minor_versions_success
    Purpose: Verify that _filter_and_process_major_minor_versions correctly selects
             the latest patch version for each (major.minor, platform_suffix) group.
    Asserts:
        - The returned list contains the correct, filtered versions.
        - The count of filtered versions is correct.
    """
    # Raw data as _filter_and_process_major_minor_versions expects it:
    # Keyed by "Major.Minor", Value is a list of version info dicts for that series and all platforms
    raw_versions_data = {
        "4.0": [
            {"version": "4.0.0", "platform_suffix": "windows-x64", "url": "win400", "hash": "h1"},
            {"version": "4.0.1", "platform_suffix": "linux-x64", "url": "lin401", "hash": "h2"},
            {"version": "4.0.2", "platform_suffix": "windows-x64", "url": "win402", "hash": "h3"},
            # Latest win-x64 for 4.0
            {"version": "4.0.0", "platform_suffix": "macos-x64", "url": "mac400", "hash": "h4"},
            # Latest mac-x64 for 4.0
            {"version": "4.0.3", "platform_suffix": "linux-x64", "url": "lin403", "hash": "h5"},
            # Latest linux-x64 for 4.0
        ],
        "4.1": [
            {"version": "4.1.0", "platform_suffix": "windows-x64", "url": "win410", "hash": "h6"},
            # Latest win-x64 for 4.1
            {"version": "4.1.1", "platform_suffix": "macos-arm64", "url": "macarm411", "hash": "h7"},
            # Latest mac-arm64 for 4.1
        ],
        "3.6": [  # This should still be processed by _filter_and_process_major_minor_versions if passed,
            # as its responsibility is *not* to filter by major version < 4.x
            {"version": "3.6.0", "platform_suffix": "windows-x64", "url": "win360", "hash": "h8"}
            # Latest win-x64 for 3.6
        ]
    }

    # Expected output (list of latest versions per (major.minor, platform_suffix) )
    # This list should reflect what _filter_and_process_major_minor_versions *itself* produces,
    # including the 3.6.0 version, as the 4.x+ filter is done at a higher level (generate_and_cache_blender_download_info).
    expected_filtered_list = [
        {"version": "3.6.0", "platform_suffix": "windows-x64", "url": "win360", "hash": "h8"},  # Included for 3.6.0
        {"version": "4.0.0", "platform_suffix": "macos-x64", "url": "mac400", "hash": "h4"},
        {"version": "4.0.2", "platform_suffix": "windows-x64", "url": "win402", "hash": "h3"},
        {"version": "4.0.3", "platform_suffix": "linux-x64", "url": "lin403", "hash": "h5"},
        {"version": "4.1.0", "platform_suffix": "windows-x64", "url": "win410", "hash": "h6"},
        {"version": "4.1.1", "platform_suffix": "macos-arm64", "url": "macarm411", "hash": "h7"},
    ]

    # Run the method under test
    filtered_versions = tool_manager_instance._filter_and_process_major_minor_versions(raw_versions_data)

    # Sort both lists for consistent comparison, as order of appending might vary by dict iteration
    filtered_versions.sort(key=lambda x: (x['version'], x['platform_suffix']))
    expected_filtered_list.sort(key=lambda x: (x['version'], x['platform_suffix']))

    # Assertions
    assert len(filtered_versions) == len(expected_filtered_list), \
        f"Expected {len(expected_filtered_list)} filtered versions, but got {len(filtered_versions)}."
    assert filtered_versions == expected_filtered_list, \
        "The filtered versions list does not match the expected list."

    print(f"\n[UNIT TEST] _filter_and_process_major_minor_versions_success passed.")

--- FILE_END: tests\unit\worker_agent\test_tool_manager.py ---
--- FILE_START: workers\__init__.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#
--- FILE_END: workers\__init__.py ---
--- FILE_START: workers\admin.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from django.contrib import admin
from .models import Worker, Job


@admin.register(Worker)
class WorkerAdmin(admin.ModelAdmin):
    list_display = ('hostname', 'ip_address', 'os', 'last_seen', 'is_active')
    list_filter = ('os', 'is_active')
    search_fields = ('hostname', 'ip_address')
    ordering = ('hostname',)

@admin.register(Job) #
class JobAdmin(admin.ModelAdmin):
    list_display = (
        'name', 'status', 'assigned_worker', 'submitted_at',
        'start_frame', 'end_frame', 'blender_version', 'render_engine'
    )
    list_filter = ('status', 'assigned_worker', 'blender_version', 'render_engine')
    search_fields = ('name', 'blend_file_path')
    date_hierarchy = 'submitted_at' # Adds date drill-down options
    ordering = ('-submitted_at',)
    # Make certain fields read-only in the admin if they should only be set programmatically
    readonly_fields = ('submitted_at', 'started_at', 'completed_at', 'last_output', 'error_message')

--- FILE_END: workers\admin.py ---
--- FILE_START: workers\apps.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from django.apps import AppConfig


class WorkersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'workers'

--- FILE_END: workers\apps.py ---
--- FILE_START: workers\migrations\__init__.py ---

--- FILE_END: workers\migrations\__init__.py ---
--- FILE_START: workers\migrations\0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-22 20:55

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Worker',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('hostname', models.CharField(max_length=255, unique=True)),
                ('ip_address', models.GenericIPAddressField(blank=True, null=True)),
                ('os', models.CharField(blank=True, default='', max_length=100)),
                ('last_seen', models.DateTimeField(auto_now=True)),
                ('is_active', models.BooleanField(default=True)),
            ],
            options={
                'ordering': ['hostname'],
            },
        ),
    ]

--- FILE_END: workers\migrations\0001_initial.py ---
--- FILE_START: workers\migrations\0002_job.py ---
# Generated by Django 5.2.4 on 2025-07-22 21:43

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('workers', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Job',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='A unique name for the render job.', max_length=255, unique=True)),
                ('blend_file_path', models.CharField(help_text='Absolute path to the Blender file.', max_length=1024)),
                ('output_file_pattern', models.CharField(help_text='Output file path pattern (e.g., //render/#.png)', max_length=1024)),
                ('start_frame', models.IntegerField(default=1)),
                ('end_frame', models.IntegerField(default=1)),
                ('status', models.CharField(choices=[('QUEUED', 'Queued'), ('RENDERING', 'Rendering'), ('DONE', 'Done'), ('ERROR', 'Error'), ('CANCELED', 'Canceled')], default='QUEUED', max_length=50)),
                ('submitted_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('started_at', models.DateTimeField(blank=True, null=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('blender_version', models.CharField(default='4.5', help_text="e.g., '4.5' or 'blender-4.5.0-windows-x64'", max_length=100)),
                ('render_engine', models.CharField(default='CYCLES', help_text="e.g., 'CYCLES' or 'BLENDER_EEVEE'", max_length=100)),
                ('last_output', models.TextField(blank=True, default='')),
                ('error_message', models.TextField(blank=True, default='')),
                ('assigned_worker', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='jobs', to='workers.worker')),
            ],
            options={
                'verbose_name': 'Render Job',
                'verbose_name_plural': 'Render Jobs',
                'ordering': ['-submitted_at'],
            },
        ),
    ]

--- FILE_END: workers\migrations\0002_job.py ---
--- FILE_START: workers\migrations\0003_worker_available_tools.py ---
# Generated by Django 5.2.4 on 2025-07-23 00:45

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('workers', '0002_job'),
    ]

    operations = [
        migrations.AddField(
            model_name='worker',
            name='available_tools',
            field=models.JSONField(blank=True, default=dict),
        ),
    ]

--- FILE_END: workers\migrations\0003_worker_available_tools.py ---
--- FILE_START: workers\models.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from django.db import models
from django.utils import timezone
from django.db.models import JSONField

class Worker(models.Model):
    hostname = models.CharField(max_length=255, unique=True)
    ip_address = models.GenericIPAddressField(null=True, blank=True)
    os = models.CharField(max_length=100, blank=True, default='')
    last_seen = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    # New field to store available tools and their versions on this worker
    # Example: {'blender': ['4.0.0', '4.1.0'], 'ffmpeg': ['6.0']}
    available_tools = JSONField(default=dict, blank=True)


    def __str__(self):
        return self.hostname

    class Meta:
        ordering = ['hostname']

# Define choices for job status
class JobStatus(models.TextChoices):
    QUEUED = 'QUEUED', 'Queued'
    RENDERING = 'RENDERING', 'Rendering'
    DONE = 'DONE', 'Done'
    ERROR = 'ERROR', 'Error'
    CANCELED = 'CANCELED', 'Canceled'


class Job(models.Model):
    name = models.CharField(max_length=255, unique=True, help_text="A unique name for the render job.")
    blend_file_path = models.CharField(max_length=1024, help_text="Absolute path to the Blender file.")
    output_file_pattern = models.CharField(max_length=1024, help_text="Output file path pattern (e.g., //render/#.png)")
    start_frame = models.IntegerField(default=1)
    end_frame = models.IntegerField(default=1)
    # Use a CharField with choices for status
    status = models.CharField(
        max_length=50,
        choices=JobStatus.choices,
        default=JobStatus.QUEUED
    )

    # Link to the Worker that's assigned this job (optional initially)
    assigned_worker = models.ForeignKey(
        'Worker',
        on_delete=models.SET_NULL, # If a worker is deleted, don't delete the job, just nullify this field
        null=True,
        blank=True,
        related_name='jobs' # Allows access from Worker.jobs.all()
    )

    submitted_at = models.DateTimeField(default=timezone.now)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    # We'll use a string for blender_version for now. Later we can make this more robust.
    blender_version = models.CharField(max_length=100, default="4.5", help_text="e.g., '4.5' or 'blender-4.5.0-windows-x64'")
    render_engine = models.CharField(max_length=100, default="CYCLES", help_text="e.g., 'CYCLES' or 'BLENDER_EEVEE'")

    # Store basic output from Blender process (for debugging/status)
    last_output = models.TextField(blank=True, default='')
    error_message = models.TextField(blank=True, default='')

    def __str__(self):
        return f"{self.name} ({self.status})"

    class Meta:
        ordering = ['-submitted_at'] # Order by most recently submitted first
        verbose_name = "Render Job"
        verbose_name_plural = "Render Jobs"
--- FILE_END: workers\models.py ---
--- FILE_START: workers\serializers.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from rest_framework import serializers
from .models import Worker, Job, JobStatus # Import Job and JobStatus

class WorkerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Worker
        fields = ['id', 'hostname', 'ip_address', 'os', 'last_seen', 'is_active', 'available_tools']
        read_only_fields = ['last_seen']

class JobSerializer(serializers.ModelSerializer):
    # Display the assigned worker's hostname directly, rather than its ID
    assigned_worker_hostname = serializers.CharField(source='assigned_worker.hostname', read_only=True)
    # Human-readable status display (e.g., "Queued" instead of "QUEUED")
    status_display = serializers.CharField(source='get_status_display', read_only=True)

    class Meta:
        model = Job
        fields = [
            'id', # Include ID for Angular to reference specific jobs
            'name',
            'blend_file_path',
            'output_file_pattern',
            'start_frame',
            'end_frame',
            'status',
            'status_display',
            'assigned_worker', # This will be the worker's ID for POST/PATCH
            'assigned_worker_hostname',
            'submitted_at',
            'started_at',
            'completed_at',
            'blender_version',
            'render_engine',
            'last_output',
            'error_message',
        ]
        read_only_fields = [
            'submitted_at', 'started_at', 'completed_at',
            'last_output', 'error_message',
            'status_display', 'assigned_worker_hostname',
        ]
        # These fields are set by backend logic/defaults, not required from client on creation
        extra_kwargs = {
            'status': {'required': False},
            'assigned_worker': {'required': False},
        }

--- FILE_END: workers\serializers.py ---
--- FILE_START: workers\tests.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from django.test import TestCase

# Create your tests here.

--- FILE_END: workers\tests.py ---
--- FILE_START: workers\urls.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import WorkerHeartbeatViewSet, JobViewSet # <-- Updated import: WorkerHeartbeatViewSet

# Create a router instance
router = DefaultRouter()
# Register your ViewSets with the router.
router.register(r'jobs', JobViewSet, basename='job')
router.register(r'heartbeat', WorkerHeartbeatViewSet, basename='heartbeat') # <-- New registration for heartbeat

urlpatterns = [
    # Include all router URLs at the root of /api/
    path('', include(router.urls)),
]
--- FILE_END: workers\urls.py ---
--- FILE_START: workers\views.py ---
#
# Copyright (c) 2025 Dryad and Naiad Software LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Created by Mario Estrella on 07/22/2025.
# Dryad and Naiad Software LLC
# mestrella@dryadandnaiad.com
# Project: sethlans_reborn
#

from rest_framework.response import Response
from rest_framework import status
from .models import Worker, Job, JobStatus
from .serializers import WorkerSerializer, JobSerializer
from django.utils import timezone

from rest_framework import viewsets
# from rest_framework.permissions import IsAuthenticatedOrReadOnly

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters  # <-- ADDED THIS IMPORT!

import logging

logger = logging.getLogger(__name__)


class WorkerHeartbeatViewSet(viewsets.ViewSet):
    """
    API endpoint for workers to send heartbeats and register themselves.
    Handles both registration (creation) and listing of workers (for debugging/admin).
    GET /api/heartbeat/ : List all registered workers.
    POST /api/heartbeat/ : Receive heartbeat/registration from a worker.
    """

    def list(self, request):
        workers = Worker.objects.all()
        serializer = WorkerSerializer(workers, many=True)
        logger.debug("Listing all registered workers.")
        return Response(serializer.data)

    def create(self, request):
        hostname = request.data.get('hostname')
        ip_address = request.data.get('ip_address')
        os_info = request.data.get('os')
        available_tools = request.data.get('available_tools', {})

        if not hostname:
            logger.error("Heartbeat: Hostname is required for worker registration.")
            return Response({"detail": "Hostname is required."}, status=status.HTTP_400_BAD_REQUEST)

        worker, created = Worker.objects.get_or_create(hostname=hostname)

        if ip_address:
            worker.ip_address = ip_address
        if os_info:
            worker.os = os_info

        if available_tools:
            worker.available_tools = available_tools

        worker.last_seen = timezone.now()
        worker.is_active = True
        worker.save()

        logger.info(
            f"Worker heartbeat/registration successful. Hostname: {worker.hostname}, ID: {worker.id}, Created: {created}, Tools: {available_tools}")

        serializer = WorkerSerializer(worker)
        return Response(serializer.data, status=status.HTTP_200_OK)


class JobViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows render jobs to be viewed or created.
    GET /api/jobs/ : List all jobs.
    POST /api/jobs/ : Create a new job.
    GET /api/jobs/{id}/ : Retrieve a specific job.
    PUT /api/jobs/{id}/ : Update a specific job.
    PATCH /api/jobs/{id}/ : Partially update a specific job.
    DELETE /api/jobs/{id}/ : Delete a specific job.
    """
    queryset = Job.objects.all()
    serializer_class = JobSerializer
    # permission_classes = [IsAuthenticatedOrReadOnly]

    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['status', 'assigned_worker']
    search_fields = ['name', 'blend_file_path']
    ordering_fields = ['submitted_at', 'status', 'name']

    def perform_create(self, serializer):
        job = serializer.save(status=JobStatus.QUEUED, submitted_at=timezone.now())
        logger.info(f"New job '{job.name}' (ID: {job.id}) created with status {job.status}.")

    def list(self, request, *args, **kwargs):
        logger.debug("API: Listing jobs.")
        return super().list(request, *args, **kwargs)

    def retrieve(self, request, *args, **kwargs):
        logger.debug(f"API: Retrieving job {kwargs.get('pk')}.")
        return super().retrieve(request, *args, **kwargs)
--- FILE_END: workers\views.py ---

--- END OF CHUNK 3 OF [TOTAL_CHUNKS_PLACEHOLDER] ---
